<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (prbnmcn-linalg.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ prbnmcn-linalg</nav><h1 id="prbnmcn-linalg:-metaprogramming-friendly-linear-algebra"><a href="#prbnmcn-linalg:-metaprogramming-friendly-linear-algebra" class="anchor"></a>prbnmcn-linalg: metaprogramming-friendly linear algebra</h1><p>This library (<code>linalg</code> for short) is a DSL allowing to construct and run computations on vectors and matrices, independently of their underlying <em>representation</em>. Concretely, this allows, given the description of a program in <code>linalg</code>, to either run this program on <code>float arrays</code> or <code>bigarrays</code>, or even to generate code.</p><nav class="toc"><ul><li><a href="#example">Example</a></li><li><a href="#introduction">Introduction</a><ul><li><a href="#abstract-vectors">Abstract vectors</a></li><li><a href="#tensor-shapes">Tensor shapes</a></li><li><a href="#vectors-and-matrices">Vectors and Matrices</a></li></ul></li><li><a href="#(todo)-reshaping">(TODO) Reshaping</a></li><li><a href="#(todo)-metaprogramming">(TODO) Metaprogramming</a></li><li><a href="#technical-notes">Technical notes</a></li><li><a href="#api">API</a></li></ul></nav></header><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>As a first example, we show how to standardize a vector. We start by computing the mean and standard deviation.</p><pre><code class="ml">open Linalg
module V = Vec.Float

let mean vec =
  let dim = Tensor.Int.numel @@ V.idim vec in
  let tot = V.reduce ( +. ) 0.0 vec in
  tot /. float_of_int dim

let stddev vec =
  let m = mean vec in
  let shape = V.idim vec in
  let idim = 1. /. float_of_int (Tensor.Int.numel shape) in
  let delta = V.sub vec (V.const shape m) in
  sqrt @@ (idim *. V.reduce ( +. ) 0.0 (V.mul delta delta))</code></pre><p>To test this out, we have to come up with a vector. Here's how to create a vector out of a <code>float array</code>.</p><pre><code class="ml">let in_of_array (a : float array) =
  let n = Array.length a in
  let shape = Tensor.Int.rank_one n in
  Vec (shape, fun i -&gt; Array.unsafe_get a i)</code></pre><p><code>in_of_array</code> returns an &quot;input vector&quot;. The <code>Vec</code> constructor packs two things:</p><ul><li>a <em>shape</em>, which embodies the valid indices into the vector as well as how to iterate on this vector,</li><li><p>a function which associates an index to a value.</p><pre><code class="ml">let test_array = [| 1.; 2.; 3. |]

let () =
  let vec = in_of_array test_array in
  assert (mean vec =. 2.) ;
  assert (String.equal (string_of_float (stddev vec)) &quot;0.816496580928&quot;)</code></pre><p>How about <em>writing back</em> to the array? We need to create an &quot;output vector&quot; as follows:</p><pre><code class="ml">let out_of_array (a : float array) =
  let n = Array.length a in
  let shape = Tensor.Int.rank_one n in
  OVec (shape, fun i v -&gt; Array.unsafe_set a i v)</code></pre><p>Using these ingredients, let's write a function that standardizes a float array:</p><pre><code class="ml">let standardize array =
  let vec = in_of_array array in
  let ovec = out_of_array array in
  let mean = mean vec in
  let std = stddev vec in
  let shape = V.idim vec in
  V.(ovec := smul (1. /. std) (sub vec (const shape mean)))

let () =
  let vec = in_of_array test_array in
  assert (mean vec =. 0.) ;
  assert (String.equal (string_of_float (stddev vec)) &quot;1.&quot;)</code></pre></li></ul><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><h3 id="abstract-vectors"><a href="#abstract-vectors" class="anchor"></a>Abstract vectors</h3><p>In <code>linalg</code>, vectors, matrices and higher tensors are represented as pairs of functions encoding getters and setters. In the following, we call these &quot;abstract vectors&quot; to distinguish them from 1d vectors. The corresponding types are <a href="Linalg/index.html#type-vec"><code>Linalg.vec</code></a>, for &quot;getters&quot; aka &quot;input vectors&quot;, and <a href="Linalg/index.html#type-ovec"><code>Linalg.ovec</code></a> for &quot;setters&quot; aka &quot;output vectors&quot;.</p><pre><code class="ml">(** Type of generic input vectors (vectors from which we {e get} elements) *)
type ('s, 'i, 'e) vec = Vec of 's * ('i -&gt; 'e)

(** Type of generic output vectors (vectors to which we {e set} elements). *)
type ('s, 'i, 'e, 'w) ovec = OVec of 's * ('i -&gt; 'e -&gt; 'w)</code></pre><p>The first type parameter <code>'s</code> corresponds to the shape of the vectors: for 1d vector, this could correspond to a contiguous interval of indices <code>0; ...; n-1</code> while for matrices, this could be the cartesian product of two such intervals, denoting every possible position in the matrix. This generalizes to higher dimensions, and even to non-regular indexation schemes.</p><p>The second parameter <code>'i</code> corresponds to the type of indices, typically we will consider integers, or some <em>representation</em> of integers (eg <code>'i</code> could be a computation yielding an integer).</p><p>The third parameter, <code>'e</code> corresponds to the type of elements. We're most used to manipulating <code>float</code>-valued vectors and matrices, but it could also be <code>Complex.t</code> or even some other vector, or some computation yielding a value!</p><p>We see that values of type <code>vec</code> are essentially functions from inputs to elements. The role of the <code>'s</code> component is to check that accesses to a vector are in the domain of that vector: obviously, the way this is performed will depend on the concrete implementation we will use for shapes.</p><p>The type <code>ovec</code> has an additional type parameter <code>'w</code>, which corresponds to the outcome of <em>writing</em> an element in a particular position. When performing run-of-the-mill computations, <code>'w</code> will correspond to the type <code>unit</code>, but again this could be something more complicated.</p><h3 id="tensor-shapes"><a href="#tensor-shapes" class="anchor"></a>Tensor shapes</h3><p>A shape specifies the domain of definition of an abstract vector and how to iterate on it. Shapes are related by shape morphisms: transporting vectors along those morphisms generalizes &quot;reshaping&quot; in other libraries.</p><p>Grid-like shapes, which are most common in practice correspond to the <a href="Linalg__/Intf/module-type-Tensor/index.html"><code>Linalg.Intf.Tensor</code></a> module type. The module <a href="Linalg__/Tensor/Int/index.html"><code>Linalg.Tensor.Int</code></a> implements this signature for the case of <code>0</code>-based indexing, column major tensor-like shapes.</p><h3 id="vectors-and-matrices"><a href="#vectors-and-matrices" class="anchor"></a>Vectors and Matrices</h3><p>The functors <a href="Linalg__/Vec/Make/index.html"><code>Linalg.Vec.Make</code></a> and <a href="Linalg__/Mat/Make/index.html"><code>Linalg.Mat.Make</code></a> are implemented on top of this infrastructure. These functors are further instantiated in directly usable modules:</p><ul><li><a href="Linalg__/Vec/Float/index.html"><code>Linalg.Vec.Float</code></a> and <a href="Linalg__/Mat/Float/index.html"><code>Linalg.Mat.Float</code></a> for manipulating resp. <code>float</code>-valued vectors and matrices</li><li><a href="Linalg__/Vec/Rational/index.html"><code>Linalg.Vec.Rational</code></a> and <a href="Linalg__/Mat/Rational/index.html"><code>Linalg.Mat.Rational</code></a> for their <code>Q</code>-valued counterparts.</li></ul><h2 id="(todo)-reshaping"><a href="#(todo)-reshaping" class="anchor"></a>(TODO) Reshaping</h2><p>TODO: document how to reshape matrices and etc</p><h2 id="(todo)-metaprogramming"><a href="#(todo)-metaprogramming" class="anchor"></a>(TODO) Metaprogramming</h2><p>TODO: document how to use <code>linalg</code> to generate code</p><h2 id="technical-notes"><a href="#technical-notes" class="anchor"></a>Technical notes</h2><p>Our approach is essentially to program numerical algorithms in tagless final form, abstracting away the typed syntax of the language in which the algorithms are implemented.</p><p>This effort is largely inspired by the work of Oleg Kiselyov et al. on <a href="http://okmij.org/ftp/meta-programming/">meta-programming</a>. The idea to represent vectors as pairs of input/output vectors, along with many other ideas, was drawn from his book <a href="http://okmij.org/ftp/meta-programming/tutorial/index.html">Reconciling Abstraction with High Performance: A MetaOCaml approach</a>.</p><p>If using <code>MetaOCaml</code> is a viable option for you, we encourage you to use it instead: indeed, our approach boils down to that of <code>MetaOCaml</code>, but without the nice syntax and extra safety brought by the scope extrusion check.</p><p>On the plus side, we can use the mainline OCaml compiler.</p><h2 id="api"><a href="#api" class="anchor"></a>API</h2><ul class="modules"><li><a href="Linalg/index.html"><code>Linalg</code></a></li></ul></div></body></html>